{
  "author": {
    "name": "Nicholas Hitchins"
  },
  "name": "ss-backbone",
  "description": "Backbone backend for SocketStream",
  "license": "MIT",
  "version": "1.0.1",
  "main": "./index.js",
  "dependencies": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "repository": {
    "type": "git",
    "url": ""
  },
  "engines": {
    "node": ">=4"
  },
  "readme": "# SS-Backbone\n\nSS-Backbone is a drop-in Backbone library for your SocketStream apps meant for realtime syncing of model data. It is still in the early days, but the goal is to make writing realtime SocketStream Backbone apps a joy by removing a lot of boilerplate setup. Any models you want to sync through a socket will inherit from a syncedModel class, and should be housed by a syncedCollection class (instructions below). All models using these prototypes will fire CRUD events at the server, and will listen for CRUD events from the server, thus keeping all connected clients up to date with the most recent state of the data.\n\nCheck out the live app at http://ss-backbone-example.jit.su/ - open in more than one browser to get the 'syncing' effect. The app is essentially copied and pasted from the [TodoMVC](http://todomvc.com) Backbone example app. All I had to do to get this working as a realtime, synced app was to have models/collections inherit from syncedModel and syncedCollection. The code for this example is here: [Todo example code](https://github.com/jkonowitch/ss-backbone/blob/master/examples/todo_example/)\n\n#### Add to your app.js:\n\tss.responders.add(require('ss-backbone'));\n\nOr:\n\n    Pass optional config options:\n    ss_backbone_opts = {\n      models: {\n        file_type: \"coffee\", // default is js\n        folder: \"backbone_models\" // with this option will look in the server/backbone_models folder\n                                  // default is server/models\n      }\n    }\n    ss.responders.add(require('ss-backbone'), ss_backbone_opts);\n\nThis provides special Model/Collection classes (see below), wires models/collections up to the server through SocketStream's socket connection, and also sends the latest Backbone (0.9.2) and Underscore (1.3.3) production files to the client.\n\n#### Synced Models\nYour realtime, synced models inherit from syncedModel and declare modelname on the class:\n\n    myModel = syncedModel.extend( {}, {modelname: \"myModel\"} );\n\n#### Synced Collections\nRealtime, synced collections inherit from syncedCollection and also declare modelname (for now):\n\n    myCollection = syncedCollection.extend( {model: myModel}, {modelname: \"myModel\"} )\n\n#### On the server [/server/models/mymodel.js]\nThis is where you decide what to do when CRUD events come in.\n\nI suggest that you read the [Todo example server](https://github.com/jkonowitch/ss-backbone/blob/master/examples/todo_example/server/backbone_models/todo.coffee) for example server logic. Models/Collections are listening for specific events, but these protocols are not yet documented. (coming soon!) See the [ss-backbone models/collections](https://github.com/jkonowitch/ss-backbone/blob/master/src/client.coffee) code for even more detail of how this works.\n\nPS: This is where I'll be focusing on providing some conventions/tools to save developers time and give them more power out of the box.\n```cofeescript\nmodule.exports = (req, res, ss) ->\n  # Preload session data in to req.session\n  req.use('session')\n\n  create: (model) ->\n    cid = req.cid\n    model.id = ids++\n    res =\n      cid: cid\n      model: model\n      method: \"confirm\"\n      modelname: \"Todo\"\n\n    memoryStore[model.id] = model\n    ss.publish.socketId req.socketId, \"sync:Todo:\" + cid, JSON.stringify(res)\n    delete res.cid\n\n    res.method = \"create\"\n    ss.publish.all \"sync:Todo\", JSON.stringify(res)\n\n  update: (model) ->\n    memoryStore[model.id] and (memoryStore[model.id] = model)\n    res =\n      model: model\n      method: \"update\"\n      modelname: \"Todo\"\n\n    res = JSON.stringify(res)\n    ss.publish.all \"sync:Todo:\" + model.id, res\n\n  read: (model) ->\n    fetchedModel = memoryStore[model.id]\n    res =\n      model: fetchedModel\n      method: \"read\"\n      modelname: \"Todo\"\n\n    ss.publish.socketId req.socketId, \"sync:Todo:\" + model.id, JSON.stringify(res)\n\n  # For collections requestions all models at once\n  readAll: (model) ->\n    models = []\n    for id of memoryStore\n      models.push memoryStore[id]\n    res =\n      models: models\n      method: \"read\"\n      modelname: \"Todo\"\n\n    ss.publish.socketId req.socketId, \"sync:Todo\", JSON.stringify(res)\n\n  delete: (model) ->\n    if delete memoryStore[model.id]\n      res =\n        method: \"delete\"\n        model: model\n        modelname: \"Todo\"\n\n      ss.publish.all \"sync:Todo:\" + model.id, JSON.stringify(res)\n```",
  "_id": "ss-backbone@1.0.1",
  "dist": {
    "shasum": "1b6f183fdb92e18876470f0b0adc247ae76e1d50"
  },
  "_from": "ss-backbone@1.0.1"
}
